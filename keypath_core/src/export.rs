use crate::{Action, Result, IR};

/// Export IR to Kanata format
pub fn export_kanata(ir: &IR) -> Result<String> {
    let mut output = String::new();

    // Header comment
    output.push_str(";; Generated by Keypath Recorder\n");
    output.push_str(";; https://github.com/malpern/keypath-recorder\n\n");

    // Define input devices (basic setup)
    output.push_str("(defsrc\n");
    output.push_str("  ");

    // Get all physical keys from IR, sorted for deterministic output
    let mut physical_keys: Vec<_> = ir.keys.keys().collect();
    physical_keys.sort();

    for (i, key) in physical_keys.iter().enumerate() {
        if i > 0 {
            output.push(' ');
        }
        output.push_str(key);
    }
    output.push_str("\n)\n\n");

    // Export macros
    if !ir.macros.is_empty() {
        output.push_str(";; Macros\n");
        for macro_name in ir.macros.keys() {
            // Basic macro support - for now just create a simple alias
            // In a full implementation, we'd parse the macro definition
            output.push_str(&format!("(defalias {} {})\n", macro_name, macro_name));
        }
        output.push('\n');
    }

    // Define aliases for tap-hold keys
    let mut aliases = Vec::new();
    for (physical_key, key_config) in &ir.keys {
        if key_config.hold.is_some() {
            let alias_name = format!("th_{}", physical_key);
            aliases.push((alias_name.clone(), physical_key, key_config));
        }
    }

    if !aliases.is_empty() {
        output.push_str(";; Tap-hold aliases\n");
        for (alias_name, physical_key, key_config) in &aliases {
            let tap_action = action_to_kanata(&key_config.tap);
            let hold_action = if let Some(hold) = &key_config.hold {
                action_to_kanata(hold)
            } else {
                physical_key.to_string()
            };

            output.push_str(&format!(
                "(defalias {} (tap-hold 200 200 {} {}))\n",
                alias_name, tap_action, hold_action
            ));
        }
        output.push('\n');
    }

    // Export layers
    if ir.layers.is_empty() {
        // Just base layer
        output.push_str("(deflayer base\n");
        output.push_str("  ");

        for (i, physical_key) in physical_keys.iter().enumerate() {
            if i > 0 {
                output.push(' ');
            }

            if let Some(key_config) = ir.keys.get(*physical_key) {
                if key_config.hold.is_some() {
                    // Use the alias for tap-hold keys
                    output.push_str(&format!("@th_{}", physical_key));
                } else if key_config.when.is_some() {
                    // Conditional mapping - for now just use the tap action
                    // TODO: Implement proper conditional logic
                    output.push_str(&action_to_kanata(&key_config.tap));
                } else {
                    // Simple tap mapping
                    output.push_str(&action_to_kanata(&key_config.tap));
                }
            } else {
                // Pass-through
                output.push_str(physical_key);
            }
        }
        output.push_str("\n)\n");
    } else {
        // Export base layer
        output.push_str("(deflayer base\n");
        output.push_str("  ");

        for (i, physical_key) in physical_keys.iter().enumerate() {
            if i > 0 {
                output.push(' ');
            }

            if let Some(key_config) = ir.keys.get(*physical_key) {
                if key_config.hold.is_some() {
                    output.push_str(&format!("@th_{}", physical_key));
                } else if key_config.when.is_some() {
                    // Conditional mapping
                    output.push_str(&action_to_kanata(&key_config.tap));
                } else {
                    output.push_str(&action_to_kanata(&key_config.tap));
                }
            } else {
                output.push_str(physical_key);
            }
        }
        output.push_str("\n)\n\n");

        // Export additional layers
        for layer_name in &ir.layers {
            output.push_str(&format!("(deflayer {}\n", layer_name));
            output.push_str("  ");

            for (i, _physical_key) in physical_keys.iter().enumerate() {
                if i > 0 {
                    output.push(' ');
                }

                // For now, all keys in additional layers are transparent
                // TODO: Add layer-specific mappings
                output.push('_');
            }
            output.push_str("\n)\n\n");
        }
    }

    Ok(output)
}

/// Convert an Action to Kanata syntax
fn action_to_kanata(action: &Action) -> String {
    match action {
        Action::Key(key) => key.clone(),
        Action::Complex(complex) => {
            if let Some(layer) = &complex.layer {
                format!("(layer-toggle {})", layer)
            } else if let Some(macro_name) = &complex.macro_name {
                format!("@{}", macro_name)
            } else {
                "_".to_string() // No-op
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{ComplexAction, Key};

    #[test]
    fn test_export_empty_ir() {
        let ir = IR::new();
        let result = export_kanata(&ir).unwrap();

        assert!(result.contains(";; Generated by Keypath Recorder"));
        assert!(result.contains("(defsrc\n  \n)"));
        assert!(result.contains("(deflayer base\n  \n)"));
    }

    #[test]
    fn test_export_simple_mapping() {
        let mut ir = IR::new();
        ir.add_key_mapping("a", "b");

        let result = export_kanata(&ir).unwrap();

        assert!(result.contains("(defsrc\n  a\n)"));
        assert!(result.contains("(deflayer base\n  b\n)"));
        assert!(!result.contains("defalias")); // No tap-hold
    }

    #[test]
    fn test_export_tap_hold_mapping() {
        let mut ir = IR::new();
        ir.keys.insert(
            "f".to_string(),
            Key {
                tap: Action::Key("f".to_string()),
                hold: Some(Action::Complex(ComplexAction {
                    layer: Some("nav".to_string()),
                    macro_name: None,
                })),
                mods: Vec::new(),
                when: None,
                macros: Vec::new(),
            },
        );

        let result = export_kanata(&ir).unwrap();

        // Should have tap-hold alias
        assert!(result.contains("(defalias th_f (tap-hold 200 200 f (layer-toggle nav)))"));
        // Should use alias in layer
        assert!(result.contains("(deflayer base\n  @th_f\n)"));
    }

    #[test]
    fn test_export_with_layers() {
        let mut ir = IR::new();
        ir.add_key_mapping("a", "a");
        ir.layers.push("nav".to_string());
        ir.layers.push("num".to_string());

        let result = export_kanata(&ir).unwrap();

        assert!(result.contains("(deflayer base\n  a\n)"));
        assert!(result.contains("(deflayer nav\n  _\n)"));
        assert!(result.contains("(deflayer num\n  _\n)"));
    }

    #[test]
    fn test_multiple_keys_sorted() {
        let mut ir = IR::new();
        ir.add_key_mapping("z", "z");
        ir.add_key_mapping("a", "a");
        ir.add_key_mapping("m", "m");

        let result = export_kanata(&ir).unwrap();

        // Keys should be sorted alphabetically
        assert!(result.contains("(defsrc\n  a m z\n)"));
        assert!(result.contains("(deflayer base\n  a m z\n)"));
    }

    #[test]
    fn test_export_with_macros() {
        let mut ir = IR::new();

        // Add a key that uses a macro
        ir.keys.insert(
            "space".to_string(),
            Key {
                tap: Action::Complex(ComplexAction {
                    layer: None,
                    macro_name: Some("space_macro".to_string()),
                }),
                hold: None,
                mods: Vec::new(),
                when: None,
                macros: Vec::new(),
            },
        );

        // Add the macro definition
        ir.macros.insert(
            "space_macro".to_string(),
            serde_json::json!({
                "sequence": ["spc", "spc"],
                "delay": 50
            }),
        );

        let result = export_kanata(&ir).unwrap();

        assert!(result.contains(";; Macros"));
        assert!(result.contains("(defalias space_macro space_macro)"));
        assert!(result.contains("@space_macro"));
    }

    #[test]
    fn test_export_with_conditions() {
        let mut ir = IR::new();

        // Add a key with a condition
        ir.keys.insert(
            "a".to_string(),
            Key {
                tap: Action::Key("b".to_string()),
                hold: None,
                mods: Vec::new(),
                when: Some("gaming_mode".to_string()),
                macros: Vec::new(),
            },
        );

        // Add the condition definition
        ir.conditions.insert(
            "gaming_mode".to_string(),
            serde_json::json!({
                "type": "layer_active",
                "layer": "gaming"
            }),
        );

        let result = export_kanata(&ir).unwrap();

        // For now, just check that the key mapping works
        // TODO: Add proper condition support to export
        assert!(result.contains("(defsrc\n  a\n)"));
        assert!(result.contains("(deflayer base\n  b\n)"));
    }

    #[test]
    fn test_action_to_kanata() {
        // Simple key
        let simple = Action::Key("a".to_string());
        assert_eq!(action_to_kanata(&simple), "a");

        // Layer toggle
        let layer = Action::Complex(ComplexAction {
            layer: Some("nav".to_string()),
            macro_name: None,
        });
        assert_eq!(action_to_kanata(&layer), "(layer-toggle nav)");

        // Macro
        let macro_action = Action::Complex(ComplexAction {
            layer: None,
            macro_name: Some("my_macro".to_string()),
        });
        assert_eq!(action_to_kanata(&macro_action), "@my_macro");

        // Empty complex action
        let empty = Action::Complex(ComplexAction {
            layer: None,
            macro_name: None,
        });
        assert_eq!(action_to_kanata(&empty), "_");
    }
}
