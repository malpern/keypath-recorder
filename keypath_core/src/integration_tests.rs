#[cfg(test)]
mod tests {
    use crate::{export_kanata, parse_ir, to_pretty_json};
    use std::fs;

    #[test]
    fn test_simple_json_roundtrip() {
        let json_content = r#"{
            "keys": {
                "a": {"tap": "b"}
            }
        }"#;

        // Parse JSON -> IR
        let ir = parse_ir(json_content).expect("Failed to parse IR");

        // Verify IR structure
        assert_eq!(ir.keys.len(), 1);
        assert!(ir.keys.contains_key("a"));

        // Export IR -> Kanata
        let kanata = export_kanata(&ir).expect("Failed to export Kanata");

        // Verify Kanata output contains expected content
        assert!(kanata.contains("(defsrc\n  a\n)"));
        assert!(kanata.contains("(deflayer base\n  b\n)"));
        assert!(kanata.contains(";; Generated by Keypath Recorder"));

        // Pretty print IR
        let pretty_json = to_pretty_json(&ir).expect("Failed to pretty print");
        assert!(pretty_json.contains("\"a\""));
        assert!(pretty_json.contains("\"b\""));
    }

    #[test]
    fn test_complex_features_integration() {
        let json_content = r#"{
            "meta": {"schema": "1.0"},
            "keys": {
                "f": {
                    "tap": "f",
                    "hold": {"layer": "nav"}
                },
                "space": {
                    "tap": {"macro_name": "double_space"},
                    "when": "editing_mode"
                }
            },
            "macros": {
                "double_space": {"sequence": ["spc", "spc"]}
            },
            "conditions": {
                "editing_mode": {"type": "layer_active", "layer": "edit"}
            },
            "layers": ["nav", "edit"]
        }"#;

        // Full pipeline test
        let ir = parse_ir(json_content).expect("Failed to parse complex IR");
        let kanata = export_kanata(&ir).expect("Failed to export complex Kanata");

        // Verify complex features are handled
        assert!(kanata.contains("(defalias th_f (tap-hold 200 200 f (layer-toggle nav)))"));
        assert!(kanata.contains("(defalias double_space double_space)"));
        assert!(kanata.contains("@th_f"));
        assert!(kanata.contains("@double_space"));
        assert!(kanata.contains("(deflayer nav"));
        assert!(kanata.contains("(deflayer edit"));
    }

    #[test]
    fn test_file_samples_integration() {
        // Test all sample files in the samples directory
        let sample_files = [
            "samples/simple.json",
            "samples/dual.json",
            "samples/macros.json",
        ];

        for sample_file in &sample_files {
            // Skip if file doesn't exist (test might run from different dir)
            if !std::path::Path::new(sample_file).exists() {
                continue;
            }

            let content = fs::read_to_string(sample_file)
                .unwrap_or_else(|_| panic!("Failed to read {}", sample_file));

            // Parse should succeed
            let ir =
                parse_ir(&content).unwrap_or_else(|_| panic!("Failed to parse {}", sample_file));

            // Export should succeed
            let kanata =
                export_kanata(&ir).unwrap_or_else(|_| panic!("Failed to export {}", sample_file));

            // Kanata output should have basic structure
            assert!(
                kanata.contains("(defsrc"),
                "Missing defsrc in {}",
                sample_file
            );
            assert!(
                kanata.contains("(deflayer base"),
                "Missing base layer in {}",
                sample_file
            );

            // Pretty print should succeed
            let _pretty = to_pretty_json(&ir)
                .unwrap_or_else(|_| panic!("Failed to pretty print {}", sample_file));
        }
    }

    #[test]
    fn test_error_handling_pipeline() {
        // Test invalid JSON
        let invalid_json = r#"{"invalid": json"#;
        assert!(parse_ir(invalid_json).is_err());

        // Test missing required fields
        let missing_keys = r#"{"meta": {"schema": "1.0"}}"#;
        assert!(parse_ir(missing_keys).is_err());

        // Test invalid key structure
        let invalid_key = r#"{"keys": {"a": "invalid"}}"#;
        assert!(parse_ir(invalid_key).is_err());
    }

    #[test]
    fn test_deterministic_output() {
        let json_content = r#"{
            "keys": {
                "z": {"tap": "z"},
                "a": {"tap": "a"},
                "m": {"tap": "m"}
            }
        }"#;

        let ir = parse_ir(json_content).expect("Failed to parse IR");

        // Export multiple times should be identical
        let kanata1 = export_kanata(&ir).expect("Failed to export 1");
        let kanata2 = export_kanata(&ir).expect("Failed to export 2");

        assert_eq!(kanata1, kanata2, "Export should be deterministic");

        // Keys should be sorted alphabetically
        assert!(kanata1.contains("(defsrc\n  a m z\n)"));
        assert!(kanata1.contains("(deflayer base\n  a m z\n)"));
    }

    #[test]
    fn test_performance_pipeline() {
        // Create a larger IR to test performance
        let mut keys = String::new();
        keys.push_str(r#"{"keys": {"#);

        for i in 0..100 {
            if i > 0 {
                keys.push(',');
            }
            keys.push_str(&format!(r#""key{}": {{"tap": "out{}"}}"#, i, i));
        }
        keys.push_str("}}");

        let start = std::time::Instant::now();
        let ir = parse_ir(&keys).expect("Failed to parse large IR");
        let parse_time = start.elapsed();

        let start = std::time::Instant::now();
        let _kanata = export_kanata(&ir).expect("Failed to export large IR");
        let export_time = start.elapsed();

        // Performance should be reasonable (these are generous limits)
        assert!(
            parse_time.as_millis() < 1000,
            "Parse took too long: {:?}",
            parse_time
        );
        assert!(
            export_time.as_millis() < 1000,
            "Export took too long: {:?}",
            export_time
        );
    }
}
